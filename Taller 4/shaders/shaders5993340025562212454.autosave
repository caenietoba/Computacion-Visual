import processing.video.*;
import processing.opengl.*;

Movie video;

float canSize = 100;
PImage label;
PShape can;
PShape cap;
float angle;

PShader selShader;

boolean useLight;
boolean useTexture;
boolean useAmbiental;
boolean useDiffuse;
boolean useSpecular;
boolean useMask;
boolean useVideo;

PShader colorShader;
PShader lightShader;
PShader texShader;
PShader texlightShader;
PShader pixlightShader;
PShader texlightxShader;
PShader bwShader;
PShader edgesShader;
PShader embossShader;

float[] edges_mask = {
  -1, -1, -1, 
  -1,  8, -1, 
  -1, -1, -1
};
                     
float[] sharpen_mask = {
  -1, -1, -1,
  -1,  9, -1,
  -1, -1, -1
};

float[] emboss_mask =
{
  -1, -1,  0,
  -1,  0,  1,
   0,  1,  1
};

float[] simple_blur_mask = {
  0.111, 0.111, 0.111, 
  0.111, 0.111, 0.111, 
  0.111, 0.111, 0.111
};

float gaussian3x3_mask[] = {
  0.077847, 0.123317, 0.077847,
  0.123317, 0.195346, 0.123317,
  0.077847, 0.123317, 0.077847,
};

float gaussian5x5_mask[] = {
  1,  4,  6,  4,  1,
  4, 16, 24, 16,  4,
  6, 24, 36.0, 24,  6,
  4, 16, 24, 16,  4,
  1,  4,  6,  4,  1,
};
                            
float[] laplacian_mask = {
  0,  0,  -1, 0,  0,
  0,  -1, -2, -1, 0,
  -1, -2, 16, -2, -1,
  0,  -1, -2, -1, 0,
  0,  0,  -1, 0,  0,
};
                        
float[] mask1 = {
  1, 1, 1, 
  1, 1, 1, 
  1, 1, 1
};
                
float[] matrix2 = { 
  -1, 0, 1,
  -1,  0, 1,
  -1, 0, 1
};
                    
float[] motion_blur_mask = {
  1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1,
};

float[] interpolation_mean_filter = {
  1/36.0,   1/36.0,   1/36.0,   1/36.0,   1/36.0,
  1/36.0,   2/36.0,   2/36.0,   2/36.0,   1/36.0,
  1/36.0,   2/36.0,   4/36.0,   2/36.0,   1/36.0,
  1/36.0,   2/36.0,   2/36.0,   2/36.0,   1/36.0,
  1/36.0,   1/36.0,   1/36.0,   1/36.0,   1/36.0
};

void setup() {
  size(1200, 700, P3D);
  
  label = loadImage("label.jpg");
  video = new Movie(this, "video.mov");
  video.loop();
  
  can = createCan(canSize, 2 * canSize, 32, video);
  cap = createCap(canSize, 32);
  //can = createCan(100, 200, 32, label);
  bwShader = loadShader("convolutionfrag.glsl");
  bwShader.set("mask", mask1);
  pixlightShader = loadShader("lightfrag.glsl", "lightvert.glsl");
  pixlightShader.set("ambientLight1", color(255,255,255));
}

void draw() {
  background(0);
  //image(video, 0, 0);
  //shader(bwShader);
  //shader(pixlightShader);
  //ambientLight(255,255,255);
  //pointLight(255, 255, 255, width/2, height, 200);
  //pointLight(255, 255, 255, width, height/2, 50);
  //pointLight(255, 255, 255, width, height, 50);
  //pointLight(255, 255, 255, 0, height/2, 200);
  drawCan(width/2, height/2, angle);
  //translate(width/2, height/2);
  //rotateY(angle);
  //rotateX(angle);
  //shape(can);
  angle += 0.01;
}

void drawCan( float centerx, float centery, float rotAngle) {
  pushMatrix();
  
  if (useLight) {
    pointLight(255, 255, 255, centerx, centery, 200);
  }
  translate(centerx, centery);
  rotateY(rotAngle);
  if (useTexture) {
    can.setTexture(video);
  } else {
    can.setTexture(video);
  }
  shape(can);
    
  resetShader();
    
  pushMatrix();
  translate(0, canSize - 5, 0);
  shape(cap);
  popMatrix();

  pushMatrix();
  translate(0, -canSize + 5, 0);
  shape(cap);
  popMatrix();
  
  popMatrix();
}

PShape createCan(float r, float h, int detail, PImage tex) {
  textureMode(NORMAL);
  PShape sh = createShape();
  sh.beginShape(QUAD_STRIP);
  sh.noStroke();
  sh.texture(tex);
  for (int i = 0; i <= detail; i++) {
    float angle = TWO_PI / detail;
    float x = sin(i * angle);
    float z = cos(i * angle);
    float u = float(i) / detail;
    sh.normal(x, 0, z);
    sh.vertex(x * r, -h/2, z * r, u, 0);
    sh.vertex(x * r, +h/2, z * r, u, 1);
  }
  sh.endShape();
  return sh;
}

PShape createCap(float r, int detail) {
  PShape sh = createShape();
  sh.beginShape(TRIANGLE_FAN);
  sh.noStroke();
  sh.fill(128);
  sh.vertex(0, 0, 0);
  for (int i = 0; i <= detail; i++) {
    float angle = TWO_PI / detail;
    float x = sin(i * angle);
    float z = cos(i * angle);
    sh.vertex(x * r, 0, z * r);
  }  
  sh.endShape();
  return sh;
}

void movieEvent(Movie m) {
  m.read();
}

void keyPressed(){
  if(key == 'v'){
    useVideo = true;
  }
  if(key == 'k'){
    useMask = true;
    useLight = false;
  }
  if(key == 'l'){
    useLight = true;
    useMask = false;
  }
  if(key == 'Ã±'){
    useLight = false;
    useMask = false;
  }
  if(key == '1' && useLight){
    useAmbiental = !useAmbiental;
  }
  if(key == '2' && useLight){
    useDiffuse = !useDiffuse;
  }
  if(key == '3' && useLight){
    useSpecular = !useSpecular;
  }
  if(key == '1' && !useLight){
    mask = edges_mask;
  }
  if(key == '2' && !useLight){
    mask = sharpen_mask;
  }
  if(key == '3' && !useLight){
    mask = emboss_mask;
  }
  if(key == '4' && !useLight){
    mask = simple_blur_mask;
  }
  if(key == '5' && !useLight){
    mask = gaussian3x3_mask;
  }
  if(key == '6' && !useLight){
    mask = gaussian5x5_mask;
  }
  if(key == '7' && !useLight){
    mask = laplacian_mask;
  }
  if(key == '8' && !useLight){
    mask = motion_blur_mask;
  }
  if(key == '9' && !useLight){
    mask = interpolation_mean_filter;
  }
}
